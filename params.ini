# spaces and tabs are ignored
# empty lines and lines that start with '#' are ignored
# this is a JSON file

{
	# the path of the relational table that is to be encoded (see "mode").
	"table_path"					: "table.csv",
	
	# the path to which the encoded oligos are stored (directories are created if not existing). Appropriate FASTA (.fa) files are created automatically.
	"encode_path"  					: "encoded",
	
	# the path to which the encoded oligos decoded to (directories are created if not existing). Appropriate text (.txt) files are created automatically.
	"decode_path"					: "decoded",
	
	# defines whether or not the encoder and decoder should perform in parallel.
	"parallel" 						: true,
	
	# select the desired mode: "encode" to only encode, "decode" to only decode from "encode_path", and "both" to encode and then decode.
	"mode"							: "both",
	
	# the maximum error for the packets and overall sequence generated by the fountain code. Consider raising this value if the fountain code is performing too slow. The error can be further reduce in the following steps, e.g., by padding and permutations. The default value 0.4 should work just fine.
	"rq_max_error"	 				: 0.4,
	
	# the final length for the Info-DNA after segmentation, if enabled (no need to adjust for permutation's prefix or padding).
	"L_{Info}"		    			: 170,
	
	# the number of permutations that are computed for each Info-DNA segment.
	"segmentation_permutations"     : 32,
	
	# the number of base pairs that are padded to each Info-DNA.
	"segmentation_gc_corrections"   : 10,

	# parameters for the CBBs
	"content-based_barcodes":
	{
		# the number of permutations that are computed for each CBB
		"permutations"    : 32,
		
		# the target length of each CBB. Note that when L_{CBB} is small, the actual length of a CBB can be longer but never smaller than L_{CBB}.
		"L_{CBB}"  : 80,
		
		# the mapping algorithm that maps the characters to DNA bases.
		# supported are: "RotatingQuattro", "RotatingTre", "Bin", and "NaiveQuattro".
		"dna_convertor"   : "RotatingQuattro"
	},

	# the list of unique attributes to encode
	"unique_attributes":
	[
		# the first unique attribute to encode
		{
			# the attribute's name
			"key": "Id",
			
			# the "key" is mapped to the Info-DNA encoding the following attributes.
			"mapping":
			{
				# attribute's name      : type.
				# defines how the attribute values shall be packed.
				# if the wrong  attribute's type was used, either "string_8" or "string_16" will be automatically used.
				# supported types:
				# "byte"      representing an 8-bit integer.
				# "short"     representing a 16-bit integer.
				# "int"       representing a 32-bit integer.
				# "long"      representing a 64-bit integer.
				# "float"     representing a 32-bit floating point.
				# "double"    representing a 64-bit floating point.
				# "string_8"  representing a string of maximum 256 characters (each character is a byte).
				# "string_16" representing a string of maximum 65536 characters (each character is a byte).
	
				"time" 					: "int",
				"timestep" 				: "short",
				"maxtimestep" 			: "short",
				"icao24" 				: "short",
				"outliers" 				: "double",
				"callsign" 				: "short",
				"heading" 				: "double",
				"baroaltitude" 			: "double",
				"lat" 					: "double",
				"lon" 					: "double",
				"velocity" 				: "double",
				"vertratecorr" 			: "double",
				"baroaltitudeanalysis"  : "double",
				"dbaroaltitudeanalysis" : "double",
				"tasanalysis" 			: "double",
				"dtasanalysis" 			: "double",
				"baroaltitudekalman" 	: "double",
				"taskalman" 			: "double",
				"segment" 				: "int",
				"modeltype"      		: "byte",
				"operator"      		: "byte",
				"ukalman"      			: "double",
				"vkalman"      			: "double",
				"tempkalman"      		: "double",
				"temp_surfacekalman"    : "double",
				"temp1000kalman"      	: "double",
				"temp2000kalman"      	: "double",
				"temp3000kalman"      	: "double",
				"temp4000kalman"      	: "double",
				"temp5000kalman"      	: "double",
				"temp6000kalman"      	: "double",
				"temp7000kalman"      	: "double",
				"temp8000kalman"      	: "double",
				"temp9000kalman"      	: "double",
				"temp10000kalman"      	: "double",
				"temp11000kalman"      	: "double",
				"tempanalysis"      	: "double",
				"target_cas1"      		: "double",
				"target_cas2"      		: "double",
				"target_Mach"      		: "double",
				"mseSpeed"      		: "double",
				"n_cas1"      			: "byte",
				"n_cas2"      			: "byte",
				"n_mach"      			: "byte",
				"fromICAO"      		: "short",
				"toICAO"      			: "short",
				"distance_from_dep"     : "double",
				"trip_distance"      	: "double",
				"massPast"      		: "double",
				"mseEnergyRatePast"     : "double",
				"massFutur"      		: "double",
				"mseEnergyRateFutur"    : "double",
				"u"      				: "double",
				"v"      				: "double",
				"temp"      			: "double",
				"tas"      				: "double"
			},
			
			# defines if the generated Info-DNAs should be segmented or not.
			"segmentation"		: true,
			
			# defines if compression should be used on the mapping attributes before encoding (but after packing).
			"gzip" 				: true
		}
	],

	# the list of non-unique attributes to encode.
	"non-unique_attributes":
	[
	# the first non-unique attribute to encode.
		{
			# the attribute's name
			"key"  			 : "icao24",
			
			# the unique attribute (e.g., the primary key) that this non-unique attribute is pointing to.
			# currently only mapping to an attribute with an integer domain is supported. However, other types could be supported with minimal changes to the code, i.e., disabling DeltaCode.
			"mapping"		 : "Id",
			
			# defines if the generated Info-DNAs should be segmented or not.
			"segmentation" 	 : true,
			
			# defines if compression should be used on the mapping attributes before encoding (but after packing).
			"gzip" 			 : true
		}
	],

	# the parameters for locality-sensitive hashing approximating the Jaccard distance.
	"lsh":
	{
		# the k-mer length.
		"k" : 6,
		
		# the number of hash functions.
		"r" : 200,
		
		# the number of bands.
		"b" : 20
	},


	# the parameters for the error function used by segmentation.
	# example: c_error : 10 and c_distance : 1 means that minimizing the error function (e.g., GC content, homopolymers, etc.) is valued 10 times higher than minimizing the distance between the sequences.
	# example: c_error : 1 and c_distance : 10 means that minimizing the distance between the sequences is 10 times higher prioritized than minimizing the error function.
	"distance_coder":
	{
		# the multiplication factor for the error function.
		"c_error"    : 1,
		
		# the multiplication factor for the distance to other sequence.
		"c_distance" : 1
	}
}